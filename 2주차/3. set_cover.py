edges=[
    (0, 2, 267), (0, 10, 292), (0, 14, 162), (0, 17, 311), (0, 23, 281), 
    (1, 11, 331), (1, 19, 307), (1, 22, 395), (2, 6, 256), (2, 10, 319), 
    (2, 14, 111), (2, 16, 316), (2, 18, 405), (2, 20, 451), (2, 21, 415), 
    (2, 24, 488), (3, 8, 249), (3, 12, 438), (3, 15, 84), (4, 7, 445), 
    (4, 10, 53), (4, 16, 320), (4, 17, 135), (4, 20, 229), (4, 24, 298), 
    (5, 9, 367), (5, 13, 483), (5, 15, 261), (5, 19, 358), (6, 7, 109), 
    (6, 12, 358), (6, 14, 319), (6, 16, 456), (6, 18, 153), (6, 21, 465), 
    (7, 12, 440), (7, 13, 465), (7, 14, 210), (7, 23, 236), (8, 9, 106), 
    (10, 16, 285), (11, 13, 371), (11, 19, 53), (12, 13, 243), (12, 18, 364), 
    (12, 21, 395), (12, 22, 442), (13, 21, 170), (14, 18, 451), (14, 23, 318),
    (16, 17, 287), (16, 23, 325), (17, 24, 392), (19, 22, 146), (20, 24, 76)
]
num_vertex = 25


print('Using Set Cover')

# Make U, F from Data
U = set(range(num_vertex)) # blank
F = [ set() for i in range(num_vertex) ] # blank
for i in range(len(edges)): # blank
    u,v,w = edges[i]
    F[u].add(u) # blank
    F[v].add(v)
    F[u].add(v)
    F[v].add(u)
    # fill F: n 번째 정점을 선택하면 i 번째 간선이 커버된다

# 구하려는 Set Cover 해 정점들
vc = set()
while U:
    # print(U)
    max_num = 0
    max_i = 0
    for i in range(len(F)):
        if max_num < len(F[i]):
            max_num = len(F[i])
            max_i = i
    # print(max_i, F[max_i])
    S = F[max_i] # U 에 살아있는 것과 가장 교집합이 많은 정점
    U -= S   # U 에서 max_i 번째 정점 선택했을 때 커버되는 간선들을 삭제한다
    F[max_i] = set() # remove max_i from F
    for i in range(len(F)):
        F[i] -= S
    vc.add(max_i)

print(len(vc), vc) # 13 {1, 3, 4, 5, 7, 9, 11, 15, 16, 19, 20, 21, 22}
